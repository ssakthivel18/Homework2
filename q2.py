# -*- coding: utf-8 -*-
"""q2.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1kiz7eVH0V0ZvTk8BnjMzXMyiWq0n2rT1
"""

import numpy as np

"""Q 2.1"""
def num_die_sum(num_die, total, trials=1000000):
  # check that total > minimum sum or < maximum sum ==> otherwise
  # there is no chance of happening ==> probability = 0.00
  if total < num_die:
    return 0
  if total > num_die * 6:
    return 0
  
  # use np.random.randint(...) to generate a matrix with the size of (# of trials, # of die)
  # where each row is a trial and each column is the value of a dice throw
  rolls = np.random.randint(1,6,(trials,num_die))

  # sum up each row to obtain the sum of each trial, use np.sum()
  sums = np.sum(rolls, axis=1)

  # how many elements in sums = the sum we are looking for?
  tally = sums.tolist().count(total)
  prob = tally / trials
  return prob

"""Q 2.2"""
def correct_papers(num_papers, trials=1000000):
    sum = 0
    # use list comprehension or np.linspace() to generate a list from 1 to num_papers (or 0 to num_papers - 1)
    papers = np.linspace(1, num_papers, num_papers, dtype=int)
    for trial in range(trials):
        permuted_papers= np.random.permutation(papers)
        count = np.count_nonzero(permuted_papers == papers)
        sum+= count
    avg = sum / trials
    return avg

correct_papers(3)

"""Q 2.3"""
def monte_carlo_pi(num_points):
    # generate pairs of (x, y) coordinates within the range of (-1, 1)
    # use np.random.rand()
    x, y = np.random.rand(num_points), np.random.rand(num_points)

    # follow the algorithm above
    in_circle = np.sqrt(x**2 + y**2) <= 1.0

    # Estimate pi as 4 times the ratio of points inside the circle to the total number of points generated
    pi = 4 * np.sum(in_circle) / num_points

    return pi

"""Q 2.4"""
def roll_until_repeat(n_sided, trials=1000000):
    total_rolls = 0
    num_rolls_per_trial = 50    # this is the number of rolls
    for i in range(trials):
      # start by using np.random.randint(...) using the num_rolls_per_trials
      rolls = np.random.randint(1, n_sided, size=num_rolls_per_trial)
      for j in range(num_rolls_per_trial):
       if rolls[j] == rolls[j-1]:
         total_rolls += j+1
         break
    avg = total_rolls / trials
    return avg

if __name__ == '__main__':
	# some test cases for you to follow
    print(num_die_sum(2, 4))              # 0.08319
    print(correct_papers(1000))           # 1.000
    print(monte_carlo_pi(1000000))        # 3.14
    print(roll_until_repeat(6, 10000))    # 5
    pass